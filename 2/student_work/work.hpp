#ifndef WORK_HPP
#define WORK_HPP

#include <iostream>
#include <istream>
#include <ostream>
#include <string>

namespace work {

#define MIN_PAGE 1
#define MIN_MARK 2
#define MAX_MARK 5
#define NO_MARK 0

/// Класс, описывающий работу студента
/*!
  Работа студента - определяется фамилией студента [в классе поле name типа
  std::string] (строка), оценкой [в классе полу mark типа unsigned int] (от 2 до
  5, также оценка может быть ещё не выставлена (равнятся нулю)), номером первого
  листа [в классе поле first_page типа unsigned int] и номером второго листа [в
  классе поле end_page типа unsigned int].

  Полностью сшитая работа начинается первым листом и заканчивается последним, но
  также предусмотрено, что разные листы работы могут быть не скреплены. То есть
  одна работа может быть представлена как множество работ, где одна работа
  начинается с листа 1 и заканчивается листом n, вторая начинается с листа n + 1
  и заканчивается листом m и т.д.

  Oценка может присутствовать только на 1-ом листе (то есть на работе,
  начинающейся с 1-ого листа).

  Терминры, встречающиеся в документации класса:
  - Выставленная оценка - это число, попадающее в диапозон от 2 до 5.
  - Невыставленная оценка - это число, равное 0.
  - Минимальная страница - это число, равное 1.
  - Правило последовательных работ:
    если одна работа имеет первую и последнюю страницу как 1 и n, а другая
  работа как n + 1 и m то работы считаются последовательными.
  - Правило установки первой и последней страницы:
    Первая страница - это минимальная страница среди полученных
    Последняя страница - это максимальная страница среди полченных
  - Правило суммирования двух работ:
    если работы имеют одинаковую фамилию, хотя бы одная из работ не имеет оценки
  и работы являются последовательными, то работы можно сложить
  - Единичная работа - это работа, первая и последняя страница которой равны.
  - Этот экземпляр класса - это экземпляр класса, на который указывает указатель
  this.
  - Другой экземлпяр класса - это экземпляр класса, полученный как параметр
  функции.
 */
class Work {
private:
  std::string name;
  unsigned mark = NO_MARK, first_page = MIN_PAGE, end_page = MIN_PAGE;

public:
  /// Конструктор по умолчанию
  /*!
    Создаёт экземпляр класса, в котором поле фамилии студента - это пустая
    строка типа std::string, поле полученной оценки невыставленна(*), номера
    первой и последней страницы - минимальная страница(*).

    (*) - см. термины в описании класса.
  */
  Work() = default;
  /// Конструктор с заданной фамилией студента
  /*!
    Создаёт экземпляр класса, в котором поле фамилии студента - это заданная
    строка, а остальные поля проинициализированы согласно конструктору по
    умолчанию для данного класса

    @param [in] name Фамилия студента
    @throws std::invalid_argument В случае, когда в фамилии студента нет данных
    (std::string.empty())
   */
  Work(std::string name);
  /// Конструктор с фамилией студента, полученной оценкой и номерами страниц
  /*!
    Создаёт экземпляр класса, в котором поле фамилии студента инициализируется
    согласно конструктору с заданной фамилией.

    Поле полученной оценки заполняется значением, полученным из аргумента.

    Первая и последняя страницы заполняются согласно правилу (*)

    @param [in] name Фамилия студента
    @param [in] mark Полученная оценка
    @param [in] page_1 Страница работы
    @param [in] page_2 Страница работы
    @throws std::invalid_argument В случае, когда полученная оценка вне
    допустимого диапозона.
    @throws std::invalid_argument В случае, когда работа не начинается с листа
    под номером 1 и оценка считается выставленной.

    (*) см. термины в описании класса.
  */

  Work(std::string name, unsigned mark, unsigned page_1, unsigned page_2);

  /// Метод, устанавливающий фамилию студента.
  /*!
    @param [in] name Фамилия студента
    @throws std::invalid_argument В случае, когда в фамилии студента нет данных
    (std::string.empty())
   */
  void set_name(std::string name);
  /// Mетод, устанавливающий полученную оценку.
  /*!
    @param [in] mark Полученная оценка
    @throws std::invalid_argument В случае, когда полученная оценка вне
    допустимого диапозона
    @throws std::invalid_argument В случае, когда работа не начинается с листа
    под номером 1 и оценка считается выставленной.
  */
  void set_mark(unsigned mark);
  /// Метод, устанавливающий страницы.
  /*!
    Первая и последняя страницы устанваливаются согласно правилу (*)

    @param [in] page_1 Страница работы
    @param [in] page_2 Страница работы
    @throws std::invalid_argument В случае, когда работа не начинается с листа
    под номером 1 и оценка считается выставленной

    (*) см. термины в описании класса.
  */
  void set_pages(unsigned page_1, unsigned page_2);

  /// Метод, возращающий фамилию студента из данного экземпляра класса
  /*!
    @returns Фамилия студента.
  */
  std::string get_name() const { return this->name; }
  /// Метод, возращающий полученную оценку из данного экземпляра класса
  /*!
    @returns Полученная оценка.
  */
  unsigned get_mark() const { return this->mark; }
  /// Метод, возращающий первую страницу из данного экземпляра класса
  /*!
    @returns Первая страница.
  */
  unsigned get_first_page() const { return this->first_page; }
  /// Метод, возращающий последнюю страницу из данного экземпляра класса
  /*!
    @returns Последняя страница.
  */
  unsigned get_end_page() const { return this->end_page; }
  /// Метод, возращающий количество страниц в данном экземпляре класса
  /*!
    @returns Количество страниц.
  */
  unsigned get_number_of_pages() const {
    return this->end_page + 1 - this->first_page;
  }

  /// Метод, разделяющий данный экземпляр класса на единичные работы (*).
  /*!
    Метод создаёт массив работ на основе количества страниц.

    Каждая работа имеет ту же фамилию студента, что и изначальная работа.

    Все полученные работы не имеют оценки (считается не выставленной), за
    исключением первой, которая получает туже самую оценку. что и изначальная
    работа.

    @returns Массив отдельный работ
    @throws std::logic_error В случае, когда фамилия студента в изначальной
    работе не имеет данных.

    (*) см. термины в описании класса.
  */
  Work *split() const;

  /// Метод, сравнивающий фамилию Этого(*) и Другого(*) экземпляра класса.
  /*!
    @param [in] other Другой экземляр класса
    @returns Результат сравнения фамилий.

    (*) см. термины в описании класса.
  */
  bool have_same_surname(const Work &other) const;
  /// Метод, проверяющий наличие полученной оценки у Этого(*) и Другого(*)
  /// экземпляра класса.
  /*!
    @param [in] other Другой экземляр класса
    @returns true если оба экземпляра имеют оценка, в противном случае false.

    (*) см. термины в описании класса.
  */
  bool have_mark_together(const Work &other) const;
  /// Метод, проверяющий являются ли Этот(*) экземлляр класса и Другой(*)
  /// последовательными(*)
  /*!
    Последовательность работ проверяется согласно правилу последовательности
    работ (*)

    @param [in] other Другой экземляр класса
    @returns true если выполняется правило последовательности, в противном
    случае false

    (*) см. термины в описании класса
  */
  bool are_consistent(const Work &other) const;
  /// Метод, проверяющий наличие возможности сложить Этот(*) и Другой(*)
  /// экземпляры класса.
  /*!
    Проверка происходит согласно правилу суммирования (*)

    @param [in] other Другой экземляр класса
    @returns true если выполняется правило суммирования, в противном случае
    false.

    (*) см. термины в описании класса.
  */
  bool can_add(const Work &other) const;

  /// Перегрузка оператора сложения
  /*!
    Возращает результат суммы двух работ:
    - Фамилия совпадает с фамилией Этого и Другого экземпляра класса.
    - Полученная оценка заполняется либо оценка Этого, либо оценкой Другого.
    - Первая страница - минимальная страница среди первых страниц Этого и
    Другого экземпляров.
    - Последняя страница - максимальна страница среди последних страниц Этого и
    Другого экземпляров.

    @param [in] other Другой экземеляр класса
    @returns Результат суммы Этого и Другого экземпляров.
    @throws std::logc_error В случае, когда экземпляры имеют разные фамилии.
    @throws std::logic_error В случае, когда оба экземпляра имеют оценку.
    @throws std::logc_error В случае, когда экземпляры не последовательны.
  */
  Work operator+(const Work &other) const;

  /// Перегрузка оператора равенства
  /*!
    Работы называются равными друг другу, если их фамилии и номера первых
    страниц совпадают друг с другом.

    @param [in] other Другой экземпляр класса
    @returns true если работы равны, в противном случае false.
  */
  bool operator==(const Work &other) const;
  /// Перегрузка оператора меньше
  /*!
    Работа меньше другой, если её фамилия или номер первой страницы меньше чем в
    другой работе.

    @param [in] other Другой экземляр класса
    @returns true если Этот экземляр меньше Другого, в противном случае false
  */
  bool operator<(const Work &other) const;

  /// Перегрузка опретора <<
  /*!
    Выводит данные Этого экземляра класса в формате:
    {фамилия_студента}' '{полученная_оценка}' '{первая_страница_работы}'
    '{последняя_страница_работы}

    @param [in] stream Поток вывода
    @param [in] work Выводимая работа
    @returns Поток вывода
  */
  friend std::ostream &operator<<(std::ostream &stream, const Work &work);
  /// Перегрузка опретора >>
  /*!
    Позволяет ввести данные для Этого экземляра класса в формате:
    {фамилия_студента}' '{полученная_оценка}' '{первая_страница_работы}'
    '{последняя_страница_работы}

    @param [in] stream Поток ввода
    @param [in] work Вводимая работа
    @returns Поток ввода
  */
  friend std::istream &operator>>(std::istream &stream, Work &work);
};
} // namespace work

#endif
